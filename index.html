<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto Metadata Tool</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¤– Auto Metadata Tool</h1>
            <p>Select a folder to generate metadata for your images</p>
        </div>

        <div class="upload-section">
            <div class="info-text">
                Select a folder containing images (JPG, PNG, GIF, WebP, etc.) and configure your LLM settings. Custom prompts will appear after folder selection.
            </div>
            <!-- Main Action Buttons Row -->
            <div class="button-row">
                <div class="file-input-wrapper">
                    <input type="file" id="folderInput" class="file-input" webkitdirectory multiple accept="image/*">
                    <button class="button file-input-button">ğŸ“ Choose Folder</button>
                </div>
                <button id="configApiBtnMain" class="button config-api-button">âš™ï¸ Configure LLM API</button>
            </div>
            
            <!-- Brand Prompt Section - Hidden until folder is selected -->
            <div class="brand-prompt-section" id="brandPromptSection" style="display: none;">
                <h3 class="brand-prompt-title">ğŸ·ï¸ Brand Prompt</h3>
                <div class="brand-prompt-description">
                    Define a brand prompt that will be used across all metadata generation to maintain consistency.
                </div>
                
                <div class="brand-prompt-container">
                    <div class="brand-prompt-field">
                        <label for="brandPromptInput" class="brand-prompt-label">Brand Prompt:</label>
                        <textarea id="brandPromptInput" class="brand-prompt-input" 
                                placeholder="Enter your brand prompt here (e.g., 'This image is for [Brand Name] marketing materials. Focus on [brand values/tone]...')"></textarea>
                    </div>
                    
                    <div class="brand-prompt-buttons">
                        <button id="saveBrandPromptBtn" class="custom-prompt-btn">ğŸ’¾ Save Brand Prompt</button>
                        <button id="clearBrandPromptBtn" class="custom-prompt-btn reset-btn">ğŸ—‘ï¸ Clear</button>
                    </div>
                </div>
            </div>

            <!-- Custom Prompts Section - Hidden until folder is selected -->
            <div class="custom-prompts-section" id="customPromptsSection" style="display: none;">
                <h3 class="custom-prompts-title">ğŸ“ Custom Prompts</h3>
                <div class="custom-prompts-description">
                    Define custom prompts for specific properties. Each property will use its own prompt to generate metadata.
                </div>
                
                <div class="custom-prompts-container">
                    <table class="custom-prompts-table">
                        <thead>
                            <tr>
                                <th>Property Name</th>
                                <th>Custom Prompt</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody id="customPromptsList">
                            <!-- Custom prompts will be dynamically added here -->
                        </tbody>
                    </table>
                    
                    <div class="custom-prompts-buttons">
                        <button id="addCustomPromptBtn" class="custom-prompt-btn">â• Add New Prompt</button>
                        <button id="saveCustomPromptsBtn" class="custom-prompt-btn">ğŸ’¾ Save Prompts</button>
                        <button id="resetCustomPromptsBtn" class="custom-prompt-btn reset-btn">ğŸ”„ Reset to Defaults</button>
                        <button id="exportPromptsBtn" class="custom-prompt-btn export-btn">ğŸ“ Export</button>
                        <button id="importPromptsBtn" class="custom-prompt-btn import-btn">ğŸ“‚ Import</button>
                        <input type="file" id="importPromptsInput" accept=".prompts,.json" style="display: none;">
                    </div>
                </div>
            </div>
            
            <div class="stats" id="stats" style="display: none;">
                <div class="stat-item">
                    <div class="stat-number" id="totalFiles">0</div>
                    <div class="stat-label">Total Files</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="imageFiles">0</div>
                    <div class="stat-label">Images</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="totalSize">0 MB</div>
                    <div class="stat-label">Total Size</div>
                </div>
            </div>
        </div>

        <div class="thumbnails-section">
            <div id="loading" class="loading" style="display: none;">
                <div class="loading-spinner"></div>
                <p>Processing images...</p>
            </div>
            
            <div id="noImages" class="no-images" style="display: none;">
                <p>ğŸ“‚ No images found in the selected folder</p>
            </div>
            
            <div id="thumbnailsContainer" style="display: none;">
                <h2 class="section-title">Auto Metadata Generation</h2>
                <div class="export-section">
                    <button id="generateAllBtn" class="export-button" style="background: linear-gradient(45deg, #fd7e14, #ffc107); color: black;">ğŸ¤– Auto-Generate All</button>
                    <button id="exportJsonBtn" class="export-button">ğŸ“„ Export as JSON</button>
                    <button id="exportCsvBtn" class="export-button">ğŸ“Š Export as CSV</button>
                    <button id="importJsonBtn" class="export-button">ğŸ“ Import JSON</button>
                    <input type="file" id="importFileInput" accept=".json" style="display: none;">
                </div>
                <div class="image-counter" id="imageCounter">Showing 0 of 0 images</div>
                <div class="thumbnails-grid" id="thumbnailsGrid"></div>
                <button id="loadMoreBtn" class="load-more-button" style="display: none;">Load More Images</button>
            </div>
        </div>
    </div>

    <!-- Modal for full-size image view -->
    <div id="imageModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <img class="modal-image" id="modalImage">
        </div>
    </div>

    <!-- Custom Prompts Modal -->
    <div id="customPromptsModal" class="api-config-modal">
        <div class="api-config-content" style="max-width: 800px; max-height: 80vh; overflow-y: auto;">
            <span class="close" style="position: absolute; top: 15px; right: 20px;">&times;</span>
            <h2 class="api-config-title">ğŸ“ Custom Prompts Management</h2>
            
            <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #28a745;">
                <h4 style="margin: 0 0 10px 0; color: #28a745;">ğŸ’¡ How it works:</h4>
                <p style="margin: 0; font-size: 0.9em; color: #666;">
                    Define custom prompts for specific properties. Each property will use its own prompt to generate metadata.
                    If no custom prompt is defined for a property, the default prompt will be used.
                </p>
            </div>
            
            <div class="custom-prompts-container">
                <table class="custom-prompts-table">
                    <thead>
                        <tr>
                            <th>Property Name</th>
                            <th>Custom Prompt</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody id="customPromptsList">
                        <!-- Custom prompts will be dynamically added here -->
                    </tbody>
                </table>
                
                <div class="custom-prompts-buttons" style="margin-top: 30px; text-align: center;">
                    <button id="addCustomPromptBtn" class="add-button">â• Add New Prompt</button>
                    <button id="saveCustomPromptsBtn" class="export-button">ğŸ’¾ Save Prompts</button>
                    <button id="resetCustomPromptsBtn" class="export-button" style="background: #dc3545;">ğŸ”„ Reset to Defaults</button>
                    <br style="margin-bottom: 10px;">
                    <button id="exportPromptsBtn" class="export-button" style="background: #007bff;">ğŸ“ Export to .prompts File</button>
                    <button id="importPromptsBtn" class="export-button" style="background: #17a2b8;">ğŸ“‚ Import from .prompts File</button>
                    <input type="file" id="importPromptsInput" accept=".prompts,.json" style="display: none;">
                    <br style="margin-bottom: 10px;">
                    <button id="cancelCustomPromptsBtn" class="export-button" style="background: #6c757d;">âŒ Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- API Configuration Modal -->
    <div id="apiConfigModal" class="api-config-modal">
        <div class="api-config-content">
            <span class="close" style="position: absolute; top: 15px; right: 20px;">&times;</span>
            <h2 class="api-config-title">ğŸ”§ Configure LLM API</h2>
            
            <div class="api-config-field">
                <label class="api-config-label" for="openaiUrlInput">LLM API URL:</label>
                <input type="url" id="openaiUrlInput" class="api-config-input" 
                       placeholder="https://api.openai.com/v1/chat/completions">
            </div>
            
            <div class="api-config-field">
                <label class="api-config-label" for="apiVersionInput">API Version:</label>
                <input type="text" id="apiVersionInput" class="api-config-input" 
                       placeholder="2024-02-15-preview">
            </div>
            
            <div class="api-config-field">
                <label class="api-config-label" for="modelNameInput">Model Name:</label>
                <input type="text" id="modelNameInput" class="api-config-input" 
                       placeholder="gpt-4-vision-preview">
            </div>
            
            <div class="api-config-field">
                <label class="api-config-label" for="deploymentInput">Deployment:</label>
                <input type="text" id="deploymentInput" class="api-config-input" 
                       placeholder="your-deployment-name">
            </div>
            
            <div class="api-config-field">
                <label class="api-config-label" for="apiKeyInput">API Key:</label>
                <input type="password" id="apiKeyInput" class="api-config-input" 
                       placeholder="Your API key (optional)">
            </div>
            
            <div class="api-config-field">
                <label class="api-config-label" for="timeoutInput">Timeout (seconds):</label>
                <input type="number" id="timeoutInput" class="api-config-input" 
                       value="30" min="5" max="120">
            </div>
            
            <div class="api-config-buttons">
                <button id="loadDefaultsBtn" class="export-button" style="background: #17a2b8;">ğŸ”„ defaults</button>
                <button id="testApiBtn" class="export-button">ğŸ§ª Test</button>
                <button id="saveApiBtn" class="export-button">ğŸ’¾ Save</button>
                <button id="cancelApiBtn" class="export-button" style="background: #6c757d;">âŒ Cancel</button>
            </div>
        </div>
    </div>

    <!-- Include the Metadata API -->
    <script src="metadata-api.js"></script>
    
    <!-- Include the Configuration -->
    <script src="config.js"></script>
    
    <!-- Include Utility Functions -->
    <script src="utils.js"></script>
    
    <!-- Include Custom Prompts Management -->
    <script src="custom-prompts.js"></script>
    
    <!-- Include Export/Import Functionality -->
    <script src="export-import.js"></script>
    
    <script>
        const folderInput = document.getElementById('folderInput');
        const loading = document.getElementById('loading');
        const noImages = document.getElementById('noImages');
        const thumbnailsContainer = document.getElementById('thumbnailsContainer');
        const thumbnailsGrid = document.getElementById('thumbnailsGrid');
        const stats = document.getElementById('stats');
        const modal = document.getElementById('imageModal');
        const modalImage = document.getElementById('modalImage');
        const closeModal = document.querySelector('.close');
        const loadMoreBtn = document.getElementById('loadMoreBtn');
        const imageCounter = document.getElementById('imageCounter');
        const exportJsonBtn = document.getElementById('exportJsonBtn');
        const exportCsvBtn = document.getElementById('exportCsvBtn');
        const importJsonBtn = document.getElementById('importJsonBtn');
        const importFileInput = document.getElementById('importFileInput');

        // Initialize Metadata API
        const metadataAPI = new MetadataAPI();

        // Configuration constants are loaded from config.js
        const imageExtensions = IMAGE_EXTENSIONS;
        const IMAGES_PER_BATCH_LOCAL = IMAGES_PER_BATCH;
        let allImageFiles = [];
        let processedImages = [];
        let currentDisplayCount = 0;
        let imageMetadata = {}; // Store metadata for each image

        folderInput.addEventListener('change', handleFolderSelection);
        
        // Add reliable click handler for the Choose Folder button
        document.querySelector('.file-input-button').addEventListener('click', function(e) {
            e.preventDefault();
            folderInput.click();
        });
        
        closeModal.addEventListener('click', () => modal.style.display = 'none');
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.style.display = 'none';
        });
        loadMoreBtn.addEventListener('click', loadMoreImages);
        
        // Initialize export/import handlers from export-import.js
        initializeExportImportHandlers();
        
        // API Configuration and Auto-generation  
        const generateAllBtn = document.getElementById('generateAllBtn');
        if (generateAllBtn) {
            generateAllBtn.addEventListener('click', generateAllMetadata);
        }

        function handleFolderSelection(event) {
            const files = Array.from(event.target.files);
            
            if (files.length === 0) return;

            // Reset state
            allImageFiles = [];
            processedImages = [];
            currentDisplayCount = 0;
            thumbnailsGrid.innerHTML = '';

            // Show loading
            loading.style.display = 'block';
            noImages.style.display = 'none';
            thumbnailsContainer.style.display = 'none';
            stats.style.display = 'none';
            loadMoreBtn.style.display = 'none';

            // Filter image files and sort them
            const imageFiles = files.filter(file => {
                const extension = file.name.split('.').pop().toLowerCase();
                return imageExtensions.includes(extension);
            }).sort((a, b) => a.name.localeCompare(b.name)); // Sort alphabetically

            allImageFiles = imageFiles;

            // Update stats
            updateStats(files, imageFiles);

            if (imageFiles.length === 0) {
                loading.style.display = 'none';
                noImages.style.display = 'block';
                // Hide brand prompt and custom prompts sections if no images found
                document.getElementById('brandPromptSection').style.display = 'none';
                document.getElementById('customPromptsSection').style.display = 'none';
                return;
            }

            // Show brand prompt and custom prompts sections now that we have images
            document.getElementById('brandPromptSection').style.display = 'block';
            document.getElementById('customPromptsSection').style.display = 'block';
            
            // Render the custom prompts list now that the section is visible
            renderCustomPromptsList();

            // Process all images but display only first batch
            processAllImages(imageFiles);
        }

        function updateStats(allFiles, imageFiles) {
            const totalSize = imageFiles.reduce((sum, file) => sum + file.size, 0);
            
            document.getElementById('totalFiles').textContent = allFiles.length;
            document.getElementById('imageFiles').textContent = imageFiles.length;
            document.getElementById('totalSize').textContent = formatFileSize(totalSize);
            
            stats.style.display = 'flex';
        }

        // formatFileSize function moved to utils.js

        function processAllImages(imageFiles) {
            let processedCount = 0;
            processedImages = [];

            imageFiles.forEach((file, index) => {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        processedImages[index] = {
                            file: file,
                            dataUrl: e.target.result,
                            index: index + 1,
                            width: this.width,
                            height: this.height
                        };
                        
                        processedCount++;
                        
                        // Show first batch when all images are processed
                        if (processedCount === imageFiles.length) {
                            loading.style.display = 'none';
                            thumbnailsContainer.style.display = 'block';
                            displayNextBatch();
                        }
                    };
                    img.src = e.target.result;
                };
                
                reader.onerror = function() {
                    console.error('Error reading file:', file.name);
                    processedCount++;
                    
                    if (processedCount === imageFiles.length) {
                        loading.style.display = 'none';
                        thumbnailsContainer.style.display = 'block';
                        displayNextBatch();
                    }
                };
                
                reader.readAsDataURL(file);
            });
        }

        function displayNextBatch() {
            const startIndex = currentDisplayCount;
            const endIndex = Math.min(startIndex + IMAGES_PER_BATCH_LOCAL, processedImages.length);
            
            for (let i = startIndex; i < endIndex; i++) {
                if (processedImages[i]) {
                    createThumbnail(processedImages[i]);
                }
            }
            
            currentDisplayCount = endIndex;
            updateImageCounter();
            
            // Show/hide load more button
            if (currentDisplayCount < processedImages.length) {
                loadMoreBtn.style.display = 'block';
                loadMoreBtn.textContent = `Load More Images (${processedImages.length - currentDisplayCount} remaining)`;
            } else {
                loadMoreBtn.style.display = 'none';
            }
        }

        function loadMoreImages() {
            displayNextBatch();
        }

        function updateImageCounter() {
            imageCounter.textContent = `Showing ${currentDisplayCount} of ${processedImages.length} images`;
        }

        function createThumbnail(imageData) {
            const thumbnailItem = document.createElement('div');
            thumbnailItem.className = 'thumbnail-item';
            
            const imageId = `img_${imageData.index}_${Date.now()}`;
            
            // Initialize metadata if not exists
            if (!imageMetadata[imageId]) {
                imageMetadata[imageId] = {
                    filename: imageData.file.name,
                    version1: {
                        title: '',
                        description: '',
                        tags: ''
                    },
                    version2: {
                        title: '',
                        description: '',
                        tags: ''
                    }
                };
            }
            
            // Index number
            const indexElement = document.createElement('div');
            indexElement.className = 'thumbnail-index';
            indexElement.textContent = `#${imageData.index}`;
            
            // Image container for centering
            const imageContainer = document.createElement('div');
            imageContainer.className = 'thumbnail-image-container';
            
            // Image
            const image = document.createElement('img');
            image.className = 'thumbnail-image';
            image.src = imageData.dataUrl;
            image.alt = imageData.file.name;
            image.loading = 'lazy';
            
            imageContainer.appendChild(image);
            
            // Info container
            const info = document.createElement('div');
            info.className = 'thumbnail-info';
            
            // File name
            const name = document.createElement('div');
            name.className = 'thumbnail-name';
            name.textContent = imageData.file.name;
            
            // Details container
            const details = document.createElement('div');
            details.className = 'thumbnail-details';
            
            // File size
            const size = document.createElement('div');
            size.className = 'thumbnail-size';
            size.textContent = formatFileSize(imageData.file.size);
            
            // Dimensions
            const dimensions = document.createElement('div');
            dimensions.className = 'thumbnail-dimensions';
            dimensions.textContent = `${imageData.width} Ã— ${imageData.height}`;
            
            // Last modified date
            const date = document.createElement('div');
            date.className = 'thumbnail-date';
            date.textContent = new Date(imageData.file.lastModified).toLocaleDateString();
            
            details.appendChild(size);
            details.appendChild(dimensions);
            details.appendChild(date);
            
            info.appendChild(name);
            info.appendChild(details);
            
            // Metadata container
            const metadataContainer = document.createElement('div');
            metadataContainer.className = 'thumbnail-metadata';
            
            // Function to create a complete metadata column with dynamic fields
            function createMetadataColumn(versionKey, columnTitle) {
                const column = document.createElement('div');
                column.className = 'metadata-column';
                
                // Column header
                const header = document.createElement('div');
                header.className = 'metadata-column-header';
                header.textContent = columnTitle;
                column.appendChild(header);
                
                // Get custom prompts to create dynamic fields
                const customPrompts = getStoredCustomPrompts();
                console.log('ğŸ”§ Creating dynamic fields for custom prompts:', customPrompts);
                
                // Initialize metadata storage for this image/version if it doesn't exist
                if (!imageMetadata[imageId]) {
                    imageMetadata[imageId] = {
                        filename: imageData.file.name,
                        version1: {}
                    };
                }
                if (!imageMetadata[imageId][versionKey]) {
                    imageMetadata[imageId][versionKey] = {};
                }
                
                // Create fields based on custom prompts (always has at least description field)
                customPrompts.forEach(promptConfig => {
                    const field = createDynamicField(
                        promptConfig.property, 
                        promptConfig.property.charAt(0).toUpperCase() + promptConfig.property.slice(1), 
                        `Generated ${promptConfig.property} will appear here...`, 
                        imageId, 
                        versionKey
                    );
                    column.appendChild(field);
                });
                
                // Auto-generate button for this column
                const generateBtn = document.createElement('button');
                generateBtn.className = 'export-button auto-generate-btn';
                generateBtn.textContent = `ğŸ¤– Auto-Generate ${columnTitle}`;
                generateBtn.onclick = () => generateMetadataForImage(imageId, versionKey, imageData, generateBtn);
                
                column.appendChild(generateBtn);
                
                return column;
            }
            
            // Helper function to create a dynamic field for any property
            function createDynamicField(property, label, placeholder, imageId, versionKey) {
                const field = document.createElement('div');
                field.className = 'metadata-field';
                field.setAttribute('data-property', property);
                
                const fieldLabel = document.createElement('label');
                fieldLabel.className = 'metadata-label';
                fieldLabel.textContent = label;
                
                // Determine if this should be a textarea or input based on common patterns
                const isTextarea = ['description', 'tags', 'keywords', 'summary', 'caption'].includes(property.toLowerCase());
                
                const input = document.createElement(isTextarea ? 'textarea' : 'input');
                if (!isTextarea) input.type = 'text';
                input.className = `metadata-input ${isTextarea ? 'metadata-textarea' : ''}`;
                input.placeholder = placeholder;
                input.value = imageMetadata[imageId][versionKey][property] || '';
                
                // Dynamic event listener for any property
                input.addEventListener('input', (e) => {
                    if (!imageMetadata[imageId][versionKey]) {
                        imageMetadata[imageId][versionKey] = {};
                    }
                    imageMetadata[imageId][versionKey][property] = e.target.value;
                    console.log(`ğŸ“ Updated ${property} for ${imageId}:`, e.target.value);
                });
                
                field.appendChild(fieldLabel);
                field.appendChild(input);
                
                // Add hint for tags-like fields
                if (['tags', 'keywords'].includes(property.toLowerCase())) {
                    const hint = document.createElement('div');
                    hint.className = 'tags-hint';
                    hint.textContent = 'Example: nature, landscape, sunset';
                    field.appendChild(hint);
                }
                
                return field;
            }
            
            // Create metadata column
            const column1 = createMetadataColumn('version1', 'Metadata');
            
            metadataContainer.appendChild(column1);
            
            thumbnailItem.appendChild(indexElement);
            thumbnailItem.appendChild(imageContainer);
            thumbnailItem.appendChild(info);
            thumbnailItem.appendChild(metadataContainer);
            
            // Add click event for modal (only on image)
            image.addEventListener('click', (e) => {
                e.stopPropagation();
                modalImage.src = imageData.dataUrl;
                modal.style.display = 'block';
            });
            
            thumbnailsGrid.appendChild(thumbnailItem);
        }

        // Keyboard navigation for modal
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && modal.style.display === 'block') {
                modal.style.display = 'none';
            }
        });

        // Auto-scroll to new images when loading more
        loadMoreBtn.addEventListener('click', () => {
            setTimeout(() => {
                const newImages = thumbnailsGrid.children;
                if (newImages.length > 0) {
                    const lastOldImage = newImages[currentDisplayCount - IMAGES_PER_BATCH_LOCAL];
                    if (lastOldImage) {
                        lastOldImage.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'start' 
                        });
                    }
                }
            }, 100);
        });

        // Export/Import functions moved to export-import.js

        /**
         * Refresh the current folder selection to update UI with new custom prompts
         */
        function refreshCurrentFolder() {
            if (allImageFiles && allImageFiles.length > 0) {
                console.log('ğŸ”„ Refreshing folder with updated custom prompts...');
                
                // Clear current display
                thumbnailsGrid.innerHTML = '';
                processedImages = [];
                currentDisplayCount = 0;
                
                // Re-process and display images with new custom prompts
                processAllImages(allImageFiles);
                
                showNotification('âœ… Folder refreshed with updated custom prompts!');
            } else {
                console.log('â„¹ï¸ No folder currently selected, nothing to refresh');
            }
        }

        // Expose refreshCurrentFolder globally for custom-prompts.js
        window.refreshCurrentFolder = refreshCurrentFolder;

        // showNotification function moved to utils.js

        // API Configuration Functions
        function showApiConfigModal() {
            const modal = document.getElementById('apiConfigModal');
            
            // Load current configuration
            const currentConfig = metadataAPI.config;
            
            // If fields are empty, populate with defaults, otherwise use current config
            document.getElementById('openaiUrlInput').value = currentConfig.openaiUrl || currentConfig.openApiUrl || DEFAULT_CONFIG.openaiUrl;
            document.getElementById('apiVersionInput').value = currentConfig.apiVersion || DEFAULT_CONFIG.apiVersion;
            document.getElementById('modelNameInput').value = currentConfig.modelName || DEFAULT_CONFIG.modelName;
            document.getElementById('deploymentInput').value = currentConfig.deployment || DEFAULT_CONFIG.deployment;
            document.getElementById('apiKeyInput').value = currentConfig.apiKey || DEFAULT_CONFIG.apiKey;
            document.getElementById('timeoutInput').value = (currentConfig.timeout / 1000) || (DEFAULT_CONFIG.timeout / 1000);
            
            modal.style.display = 'block';
        }

        function saveApiConfiguration() {
            const openaiUrl = document.getElementById('openaiUrlInput').value.trim();
            const apiVersion = document.getElementById('apiVersionInput').value.trim();
            const modelName = document.getElementById('modelNameInput').value.trim();
            const deployment = document.getElementById('deploymentInput').value.trim();
            const apiKey = document.getElementById('apiKeyInput').value.trim();
            const timeout = parseInt(document.getElementById('timeoutInput').value) * 1000;

            metadataAPI.setConfig({
                openaiUrl: openaiUrl,
                openApiUrl: openaiUrl,  // Support both field names
                apiVersion: apiVersion,
                modelName: modelName,
                deployment: deployment,
                apiKey: apiKey,
                timeout: timeout,
                customPrompt: DEFAULT_CONFIG.customPrompt
            });

            // Save to localStorage for persistence
            localStorage.setItem('metadataApiConfig', JSON.stringify({
                openaiUrl: openaiUrl,
                apiVersion: apiVersion,
                modelName: modelName,
                deployment: deployment,
                apiKey: apiKey,
                timeout: timeout
            }));

            document.getElementById('apiConfigModal').style.display = 'none';
            showNotification('âœ… API configuration saved successfully!');
        }

        function loadApiConfiguration() {
            try {
                const savedConfig = localStorage.getItem('metadataApiConfig');
                if (savedConfig) {
                    const config = JSON.parse(savedConfig);
                    metadataAPI.setConfig(config);
                    console.log('Loaded API configuration from localStorage');
                }
            } catch (error) {
                console.error('Error loading API configuration:', error);
            }
        }

        async function testApiConfiguration() {
            const testBtn = document.getElementById('testApiBtn');
            const originalText = testBtn.textContent;
            
            testBtn.textContent = 'ğŸ§ª Testing...';
            testBtn.disabled = true;

            try {
                // First save the current configuration temporarily
                const openaiUrl = document.getElementById('openaiUrlInput').value.trim();
                const apiVersion = document.getElementById('apiVersionInput').value.trim();
                const modelName = document.getElementById('modelNameInput').value.trim();
                const deployment = document.getElementById('deploymentInput').value.trim();
                const apiKey = document.getElementById('apiKeyInput').value.trim();
                const timeout = parseInt(document.getElementById('timeoutInput').value) * 1000;

                const tempAPI = new MetadataAPI();
                tempAPI.setConfig({
                    openaiUrl: openaiUrl,
                    openApiUrl: openaiUrl,  // Support both field names
                    apiVersion: apiVersion,
                    modelName: modelName,
                    deployment: deployment,
                    apiKey: apiKey,
                    timeout: timeout,
                    customPrompt: DEFAULT_CONFIG.customPrompt
                });

                const result = await tempAPI.testConfiguration();
                
                if (result) {
                    showNotification('âœ… API configuration test successful!');
                } else {
                    showNotification('âš ï¸ API test completed with warnings - check console for details.', 'warning');
                }
            } catch (error) {
                showNotification('âŒ API configuration test failed: ' + error.message, 'error');
            } finally {
                testBtn.textContent = originalText;
                testBtn.disabled = false;
            }
        }

        // Auto-generation Functions
        async function generateMetadataForImage(imageId, versionKey, imageData, buttonElement) {
            const originalText = buttonElement.textContent;
            buttonElement.textContent = 'ğŸ”„ Generating...';
            buttonElement.disabled = true;
            
            try {
                const imageInfo = {
                    width: imageData.width,
                    height: imageData.height,
                    format: imageData.file.name.split('.').pop().toLowerCase(),
                    size: imageData.file.size,
                    filename: imageData.file.name
                };

                let metadata;
                if (versionKey === 'version1') {
                    // Check if we have custom prompts defined
                    const customPrompts = getStoredCustomPrompts();
                    console.log('ğŸ” DEBUG: Loaded custom prompts:', customPrompts);
                    
                    if (customPrompts.length > 0) {
                        console.log(`ğŸ¯ Using ${customPrompts.length} custom prompts for property-specific generation`);
                        console.log('ğŸ” DEBUG: Custom prompts details:', customPrompts.map(p => ({property: p.property, promptLength: p.prompt.length})));
                        
                        // Generate using custom prompts for each property
                        const results = {};
                        
                        for (const promptConfig of customPrompts) {
                            try {
                                console.log(`ğŸ”„ Generating '${promptConfig.property}' using custom prompt (${promptConfig.prompt.substring(0, 100)}...)`);
                                fullPrompt = concatenateImageInfoWithPrompt(imageInfo, promptConfig.prompt);
                                const propertyResult = await metadataAPI.generateCustomPropertyMetadata(
                                    imageData.dataUrl, 
                                    imageInfo, 
                                    promptConfig.property, 
                                    fullPrompt
                                );
                                
                                console.log(`ğŸ” DEBUG: Raw API response for '${promptConfig.property}':`, propertyResult);
                                
                                // Enhanced property value extraction to handle raw responses
                                let propertyValue = '';
                                
                                if (typeof propertyResult === 'string') {
                                    // Direct string response
                                    propertyValue = propertyResult.trim();
                                    console.log(`ğŸ” DEBUG: Direct string response: "${propertyValue}"`);
                                } else if (propertyResult && typeof propertyResult === 'object') {
                                    console.log(`ğŸ” DEBUG: Object response fields:`, Object.keys(propertyResult));
                                    
                                    // First check if the property name matches exactly
                                    if (propertyResult[promptConfig.property]) {
                                        propertyValue = propertyResult[promptConfig.property];
                                        console.log(`ğŸ” DEBUG: Found exact property match: "${propertyValue}"`);
                                    } 
                                    // Then check common fields in order of preference
                                    else if (propertyResult.title) {
                                        propertyValue = propertyResult.title;
                                        console.log(`ğŸ” DEBUG: Extracted from .title field: "${propertyValue}"`);
                                    } else if (propertyResult.description) {
                                        propertyValue = propertyResult.description;
                                        console.log(`ğŸ” DEBUG: Extracted from .description field: "${propertyValue}"`);
                                    } else if (propertyResult.tags) {
                                        propertyValue = propertyResult.tags;
                                        console.log(`ğŸ” DEBUG: Extracted from .tags field: "${propertyValue}"`);
                                    } else if (propertyResult.content) {
                                        propertyValue = propertyResult.content;
                                        console.log(`ğŸ” DEBUG: Extracted from .content field: "${propertyValue}"`);
                                    } 
                                    // If no standard fields, check for raw response content (error cases)
                                    else {
                                        // Look for any field that contains substantial text content
                                        const textFields = Object.keys(propertyResult).filter(key => 
                                            typeof propertyResult[key] === 'string' && 
                                            propertyResult[key].length > 10 && 
                                            !['provider', 'generated_at', 'error'].includes(key)
                                        );
                                        
                                        if (textFields.length > 0) {
                                            propertyValue = propertyResult[textFields[0]];
                                            console.log(`ğŸ” DEBUG: Using text field '${textFields[0]}': "${propertyValue.substring(0, 100)}..."`);
                                        } else {
                                            // Last resort: stringify the entire response
                                            propertyValue = JSON.stringify(propertyResult, null, 2);
                                            console.log(`ğŸ” DEBUG: No text fields found, using full response: "${propertyValue.substring(0, 100)}..."`);
                                        }
                                    }
                                } else {
                                    // Fallback: convert whatever we got to string
                                    propertyValue = String(propertyResult || '');
                                    console.log(`ğŸ” DEBUG: Fallback conversion to string: "${propertyValue}"`);
                                }
                                
                                results[promptConfig.property] = propertyValue;
                                console.log(`âœ… Generated '${promptConfig.property}': "${propertyValue}"`);
                                
                            } catch (error) {
                                console.error(`âŒ Error generating '${promptConfig.property}':`, error);
                                results[promptConfig.property] = `Error: ${error.message}`;
                            }
                        }
                        
                        console.log('ğŸ” DEBUG: All results before mapping:', results);
                        
                        // Create dynamic metadata object based on custom prompts
                        metadata = {
                            provider: 'openai',
                            generated_at: new Date().toISOString()
                        };
                        
                        // Add all custom prompt results to the metadata object
                        Object.keys(results).forEach(property => {
                            metadata[property] = results[property];
                        });
                        
                        console.log('ğŸ‰ Dynamic metadata result:', metadata);
                        console.log(`ğŸ” DEBUG: Properties included:`, Object.keys(metadata));
                        
                    } else {
                        console.log('ğŸ“ No custom prompts found, using default prompt');
                        // Use default prompt
                        metadata = await metadataAPI.generateAIMetadata(imageData.dataUrl, imageInfo);
                    }
                } else {
                    metadata = await metadataAPI.generateLlamaMetadata(imageData.dataUrl, imageInfo);
                }

                        // Update the metadata storage dynamically
        if (!imageMetadata[imageId]) {
            imageMetadata[imageId] = {
                filename: imageData.file.name,
                version1: {}
            };
        }
        
        // Store all metadata properties dynamically
        if (!imageMetadata[imageId][versionKey]) {
            imageMetadata[imageId][versionKey] = {};
        }
        
        // Copy all metadata properties except system fields
        Object.keys(metadata).forEach(key => {
            if (key !== 'provider' && key !== 'generated_at') {
                imageMetadata[imageId][versionKey][key] = metadata[key];
            }
        });

                // Update the UI inputs dynamically based on the metadata properties
                const column = buttonElement.closest('.metadata-column');
                const metadataFields = column.querySelectorAll('.metadata-field');
                
                // Update each field based on its data-property attribute
                metadataFields.forEach(field => {
                    const property = field.getAttribute('data-property');
                    if (property && metadata.hasOwnProperty(property)) {
                        const input = field.querySelector('.metadata-input');
                        if (input) {
                            input.value = metadata[property] || '';
                            console.log(`ğŸ”„ Updated UI field '${property}': "${metadata[property]}"`);
                        }
                    }
                });
                
                // Also store the complete metadata object
                Object.keys(metadata).forEach(key => {
                    if (key !== 'provider' && key !== 'generated_at') {
                        imageMetadata[imageId][versionKey][key] = metadata[key];
                    }
                });

                // Show success status
                let statusElement = column.querySelector('.generate-status');
                if (!statusElement) {
                    statusElement = document.createElement('div');
                    statusElement.className = 'generate-status';
                    column.appendChild(statusElement);
                }
                statusElement.textContent = 'âœ… Generated successfully';
                
                setTimeout(() => {
                    if (statusElement.parentNode) {
                        statusElement.remove();
                    }
                }, 3000);

            } catch (error) {
                console.error('Error generating metadata:', error);
                showNotification('âŒ Failed to generate metadata: ' + error.message, 'error');
                
                // Populate UI fields with error information instead of leaving them empty
                const column = buttonElement.closest('.metadata-column');
                const metadataFields = column.querySelectorAll('.metadata-field');
                const errorMessage = `âŒ Error: ${error.message}`;
                
                metadataFields.forEach(field => {
                    const property = field.getAttribute('data-property');
                    if (property) {
                        const input = field.querySelector('.metadata-input');
                        if (input) {
                            input.value = errorMessage;
                            console.log(`ğŸ”§ Populated field '${property}' with error message`);
                        }
                        
                        // Also store in metadata
                        if (!imageMetadata[imageId]) {
                            imageMetadata[imageId] = { filename: imageData.file.name, version1: {} };
                        }
                        if (!imageMetadata[imageId][versionKey]) {
                            imageMetadata[imageId][versionKey] = {};
                        }
                        imageMetadata[imageId][versionKey][property] = errorMessage;
                    }
                });
                
            } finally {
                buttonElement.textContent = originalText;
                buttonElement.disabled = false;
            }
        }

        async function generateAllMetadata() {
            const generateBtn = document.getElementById('generateAllBtn');
            const originalText = generateBtn.textContent;
            
            generateBtn.textContent = 'ğŸ”„ Generating All...';
            generateBtn.disabled = true;

            try {
                const thumbnailItems = document.querySelectorAll('.thumbnail-item');
                let totalGenerated = 0;
                let totalErrors = 0;

                for (const item of thumbnailItems) {
                    const generateButtons = item.querySelectorAll('.auto-generate-btn');
                    
                    for (const button of generateButtons) {
                        try {
                            await button.click();
                            totalGenerated++;
                        } catch (error) {
                            console.error('Error in batch generation:', error);
                            totalErrors++;
                        }
                        
                        // Small delay to avoid overwhelming the API
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }

                showNotification(`âœ… Batch generation completed! Generated: ${totalGenerated}, Errors: ${totalErrors}`);

            } catch (error) {
                console.error('Error in batch generation:', error);
                showNotification('âŒ Batch generation failed: ' + error.message, 'error');
            } finally {
                generateBtn.textContent = originalText;
                generateBtn.disabled = false;
            }
        }

        // Custom Prompts Management functions moved to custom-prompts.js


        // Modal Event Handlers
        document.addEventListener('DOMContentLoaded', function() {
            // Auto-load default configuration if none exists
            autoLoadDefaultsIfNeeded();
            
            // Load saved API configuration
            loadApiConfiguration();
            
            // API Config modal handlers
            const apiConfigModal = document.getElementById('apiConfigModal');
            const apiConfigClose = apiConfigModal.querySelector('.close');
            const configApiBtnMain = document.getElementById('configApiBtnMain');
            const loadDefaultsBtn = document.getElementById('loadDefaultsBtn');
            const saveApiBtn = document.getElementById('saveApiBtn');
            const cancelApiBtn = document.getElementById('cancelApiBtn');
            const testApiBtn = document.getElementById('testApiBtn');

            // Initialize custom prompts handlers from custom-prompts.js
            initializeCustomPromptsHandlers();
            
            // Load custom prompts and brand prompt data but don't render yet (sections are hidden)
            loadCustomPrompts();
            loadBrandPrompt();

            apiConfigClose.addEventListener('click', () => {
                apiConfigModal.style.display = 'none';
            });

            // Add event listener for the main configuration button
            configApiBtnMain.addEventListener('click', showApiConfigModal);
            
            loadDefaultsBtn.addEventListener('click', populateConfigFormWithDefaults);
            saveApiBtn.addEventListener('click', saveApiConfiguration);
            cancelApiBtn.addEventListener('click', () => {
                apiConfigModal.style.display = 'none';
            });
            testApiBtn.addEventListener('click', testApiConfiguration);

            // Close modal when clicking outside
            apiConfigModal.addEventListener('click', (e) => {
                if (e.target === apiConfigModal) {
                    apiConfigModal.style.display = 'none';
                }
            });


        });
    </script>
</body>
</html> 